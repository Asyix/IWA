import Foundation

// Refund Model
class Refund: ObservableObject, Hashable {
    private(set) var id: String
    @Published var sellerId: String
    @Published var sessionId: String
    @Published var managerId: String
    @Published var refundAmount: Double
    @Published var depositDate: Date

    // Initializer from RefundDTO
    init(from dto: RefundDTO) {
        self.id = dto._id
        self.sellerId = dto.sellerId
        self.sessionId = dto.sessionId
        self.managerId = dto.managerId
        self.refundAmount = dto.refundAmount
        self.depositDate = JSONHelper.dateFormatter.date(from: dto.depositDate) ?? Date()
    }
    
    static func == (lhs: Refund, rhs: Refund) -> Bool {
        return lhs.id == rhs.id
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}

// DTO for Refund
struct RefundDTO: Codable {
    var _id: String  // The ID is generated by the backend
    var sellerId: String
    var sessionId: String
    var managerId: String
    var refundAmount: Double
    var depositDate: String  // The date as a string, to be converted
}

// CreateRefundDTO - for creating a refund
struct CreateRefundDTO: Codable {
    var sellerId: String
    var sessionId: String
    var refundAmount: Double
    var depositDate: String  // Date should be a string in the required format
}

// UpdateRefundDTO - for updating an existing refund
struct UpdateRefundDTO: Codable {
    var id: String
    var sellerId: String
    var sessionId: String
    var managerId: String
    var refundAmount: Double
    var depositDate: Date  // Date for update should be in Date format
}

